<html>
<title>文件系统</title>
<body>
<h1>文件系统</h1>
<h3>
Python标准库包含一大堆工具在文件系统上用来与文件一起工作，建立和检查文件名，以及检验文件内容。
</h3>
<p>
在与文件的工作中第一步是确定文件的名字。Python呈现文件名字是以简单的字符串形式，但从标准中为了建立文件而提供的工具，平台独立的组件在os.path中。列出一个目录的内容使用os.listdir()，或者用glob从一个模式建立一个文件名字的列表。
</p>
<p>
通过使用glob.fnmatch，文件名字模式比对也被直接暴露出来，所以它能用在其它内容中。
</p>
<p>
dircache提供了一个有效的方式在文件系统上来扫描和处理一个目录的内容，当处理文件的时候所在之处在进展中并不知道名字。
</p>
<p>
文件的名字被鉴定之后，其它特点，例如权限或者文件大小，能使用os.stat()来检查，并且在stat中要有常量。
</p>
<p>
当一个应用需要任意入口到达文件的时候，linecache会容易通过它们的行数字来读取行。文件的内容是在一个缓存中维护的，所以小心内存消耗。
</p>
<p>
需要建立草稿文件临时地保持数据使用tempfile很有用，或者在移动tempfile到一个永久位置之前。tempfile提供了类来安全地建立临时文件和目录。名字被保存成独特和含有任意成分，所以它们是不容易被猜到的。
</p>
<p>
经常地，作为一个整体程序需要工作在文件上，没有视为它们的内容。shutil模块包含高级别文件操作，例如复制文件和复制文件夹，以及设置权限。
</p>
<p>
filecmp模块通过查看字节来对比文件和文件夹，但不包含任何有关格式的特殊知识。
</p>
<p>
built-in内置函数file类能被用来读写本地文件系统上看得到的文件。一个程序的表现能忍受当程序通过read()和write()接口进入大文件时，尽管，当它们都卷入了复制数据很多次，数据从磁盘移动到内存，程序都能看到。使用mmap通过一个程序告诉操作系统使用虚拟内存子系统直接映射一个文件的内容到内存是可行的，为file对象在操作系统和内部缓存之间避免一个复制步骤。
</p>
<p>
使用字符的文本数据在ASCII里是无效的，ASCII经常被存储在一个Unicode数据格式里。因此标准file处理认为一个文本文件的每个字节是一个字符，用多字节编码读取Unicode文本需要额外的进程（对进程的理解，这里可以翻译成“额外的步骤”）。codecs模块自动处理编码和解码，所以在很多情况中，一个非ASCII文件能在没有任何其它变化下被使用。
</p>
<p>
为了测试代码，依靠从文件读、写数据，StringIO提供了一个在内存中的流对象，这个内存流对象表现的像一个文件，但并不存在在磁盘上。
</p>
<fieldset id="6.1">
<legend>os.path平台——文件名的独立控制</legend>
<h3>目的：在文件名和路径上进行语法分析，建立，测试以及其它工作。</h3>
<p>使用os.path模块中的函数写代码达到与文件一起工作在多平台上是容易的。</p>
</fieldset>
</body>
<html>